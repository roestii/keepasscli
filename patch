diff --git a/src/main.zig b/src/main.zig
index a2894d1..c3f22d3 100644
--- a/src/main.zig
+++ b/src/main.zig
@@ -1,7 +1,55 @@
 const std = @import("std");
+const argon2 = std.crypto.pwhash.argon2;
+const sha2 = std.crypto.hash.sha2;
 
 // TODO: Put this in a separate file
 
+const Reader = struct {
+    ptr: []u8,
+    idx: u32,
+
+    fn readN(self: *Reader, n: u32) []u8 {
+        const res = self.ptr[self.idx .. self.idx + n];
+        self.idx += n;
+        return res;
+    }
+
+    fn readByte(self: *Reader) u8 {
+        const res: u8 = self.ptr[self.idx];
+        self.idx += 1;
+        return res;
+    }
+
+    fn readU16(self: *Reader) u16 {
+        const res: u16 = @as(u16, @intCast(self.ptr[self.idx])) 
+            | @as(u16, @intCast(self.ptr[self.idx + 1])) << @intCast(8);
+        self.idx += 2;
+        return res;
+    }
+
+    fn readU32(self: *Reader) u32 {
+        const res: u32 = @as(u32, @intCast(self.ptr[self.idx])) 
+            | @as(u32, @intCast(self.ptr[self.idx + 1])) << @intCast(8) 
+            | @as(u32, @intCast(self.ptr[self.idx + 2])) << @intCast(16) 
+            | @as(u32, @intCast(self.ptr[self.idx + 3])) << @intCast(24);
+        self.idx += 4;
+        return res;
+    }
+
+    fn readU64(self: *Reader) u64 {
+        const res: u64 = @as(u64, @intCast(self.ptr[self.idx])) 
+            | @as(u64, @intCast(self.ptr[self.idx + 1])) << @intCast(8) 
+            | @as(u64, @intCast(self.ptr[self.idx + 2])) << @intCast(16) 
+            | @as(u64, @intCast(self.ptr[self.idx + 3])) << @intCast(24) 
+            | @as(u64, @intCast(self.ptr[self.idx + 4])) << @intCast(32) 
+            | @as(u64, @intCast(self.ptr[self.idx + 5])) << @intCast(40) 
+            | @as(u64, @intCast(self.ptr[self.idx + 6])) << @intCast(48) 
+            | @as(u64, @intCast(self.ptr[self.idx + 7])) << @intCast(54);
+        self.idx += 8;
+        return res;
+    }
+};
+
 const AES256 = [_]u8{ 
     0x31, 0xC1, 0xF2, 0xE6, 0xBF, 0x71, 0x43, 0x50, 0xBE, 0x58, 0x05, 0x21, 0x6A, 0xFC, 0x5A, 0xF 
 };
@@ -59,36 +107,16 @@ const Header = struct {
     customData: ?CustomData 
 };
 
-fn byteSliceToU64(ptr: []u8) u64 {
-    const res: u64 = @as(u64, @intCast(ptr[0])) | @as(u64, @intCast(ptr[1])) << @intCast(8) | @as(u64, @intCast(ptr[2])) << @intCast(16) | @as(u64, @intCast(ptr[3])) << @intCast(24) | @as(u64, @intCast(ptr[4])) << @intCast(32) | @as(u64, @intCast(ptr[5])) << @intCast(40) | @as(u64, @intCast(ptr[6])) << @intCast(48) | @as(u64, @intCast(ptr[7])) << @intCast(54);
-
-    return res;
-}
-
-fn byteSliceToU32(ptr: []u8) u32 {
-    const res: u32 = @as(u32, @intCast(ptr[0])) | @as(u32, @intCast(ptr[1])) << @intCast(8) | @as(u32, @intCast(ptr[2])) << @intCast(16) | @as(u32, @intCast(ptr[3])) << @intCast(24);
-
-    return res;
-}
-
-fn byteSliceToU16(ptr: []u8) u16 {
-    const res: u16 = @as(u16, @intCast(ptr[0])) | @as(u16, @intCast(ptr[1])) << @intCast(8);
-    return res;
-}
-
-fn parseKdfParams(ptr: []u8) Error!KdfParams {
+fn parseKdfParams(r: *Reader) Error!KdfParams {
     var kdfParams: ?KdfParams = null;
-    var offset: usize = 0;
-    const v: u16 = byteSliceToU16(ptr[0..2]);
-    offset += 2;
+    const v: u16 = r.readU16();
 
     if (v != 0x100) {
         return Error.UnsupportedKDFVersion;
     }
 
     while (true) {
-        const kind = ptr[offset];
-        offset += 1;
+        const kind = r.readByte();
 
         switch (kind) {
             0x00 => {
@@ -97,16 +125,12 @@ fn parseKdfParams(ptr: []u8) Error!KdfParams {
                 return kdfParams.?;
             },
             else => {
-                const nameSize = byteSliceToU32(ptr[offset .. offset + 4]);
-                offset += 4;
-                const name = ptr[offset .. offset + nameSize];
-                offset += nameSize;
-                const valueSize = byteSliceToU32(ptr[offset .. offset + 4]);
-                offset += 4;
-                const value = ptr[offset .. offset + valueSize];
-                offset += valueSize;
+                const nameSize = r.readU32();
+                const name = r.readN(nameSize);
+                const valueSize = r.readU32();
 
                 if (std.mem.eql(u8, name, "$UUID")) {
+                    const value = r.readN(valueSize);
                     if (std.mem.eql(u8, value, &AESKDF)) {
                         kdfParams = KdfParams{ 
                             .aesKdf = AESKdfParams{
@@ -136,24 +160,27 @@ fn parseKdfParams(ptr: []u8) Error!KdfParams {
                     switch (kdfParams.?) {
                         .aesKdf => |*params| {
                             if (std.mem.eql(u8, name, "R")) {
-                                params.*.rounds = byteSliceToU64(value);
+                                std.debug.assert(valueSize == 8);
+                                params.*.rounds = r.readU64(); 
                             } else if (std.mem.eql(u8, name, "S")) {
-                                params.*.salt = value;
+                                std.debug.assert(valueSize == 8);
+                                params.*.salt = r.readN(valueSize);
                             } else {
                                 return Error.CorruptedHeader;
                             }
                         },
                         .argon2 => |*params| {
                             if (std.mem.eql(u8, name, "V")) {
-                                params.*.version = byteSliceToU32(value);
+                                std.debug.assert(valueSize == 4);
+                                params.*.version = r.readU32(); 
                             } else if (std.mem.eql(u8, name, "S")) {
-                                params.*.salt = value;
+                                params.*.salt = r.readN(valueSize);
                             } else if (std.mem.eql(u8, name, "I")) {
-                                params.*.it = byteSliceToU64(value);
+                                params.*.it = r.readU64();
                             } else if (std.mem.eql(u8, name, "M")) {
-                                params.*.mem = byteSliceToU64(value);
+                                params.*.mem = r.readU64();
                             } else if (std.mem.eql(u8, name, "P")) {
-                                params.*.par = byteSliceToU32(value);
+                                params.*.par = r.readU32();
                             } else {
                                 return Error.CorruptedHeader;
                             }
@@ -171,17 +198,45 @@ fn parseCustomData(_: []u8) Error!CustomData {
     return Error.CorruptedHeader;
 }
 
-fn parseHeader(ptr: []u8) Error!Header {
-    var header: Header = Header{ .encAlgo = null, .compAlgo = null, .salt = null, .nonce = null, .kdfParams = null, .customData = null };
-    var offset: usize = 0;
-
+fn parseInnerHeader(r: *Reader) void {
     while (true) {
-        const id = ptr[offset];
-        offset += 1;
+        const kind = r.readByte();
+        const size = r.readU32();
 
-        // TODO: move constant values into constant assignments
-        const size: u32 = byteSliceToU32(ptr[offset .. offset + 4]);
-        offset += 4;
+        switch (kind) {
+            0 => {
+                // end of header
+                return;
+            },
+            1 => {
+                // inner encryption algorithm, int32
+                std.debug.assert(size == 4);
+                const innerEncAlgo = r.readU32();
+                std.debug.print("{}\n", .{innerEncAlgo});
+            },
+            2 => {
+                // inner encryption, bytes
+            },
+            3 => {
+                // binary content, bytes
+            },
+        }
+    }
+}
+
+fn parseHeader(r: *Reader) Error!Header {
+    var header: Header = Header{ 
+        .encAlgo = null, 
+        .compAlgo = null, 
+        .salt = null, 
+        .nonce = null, 
+        .kdfParams = null, 
+        .customData = null 
+    };
+
+    while (true) {
+        const id = r.readByte();
+        const size: u32 = r.readU32();
 
         switch (id) {
             0 => {
@@ -190,79 +245,119 @@ fn parseHeader(ptr: []u8) Error!Header {
             2 => {
                 // encryption algorithm, 16 bytes
                 std.debug.assert(size == 16);
-                const encAlgo = ptr[offset .. offset + size];
-                header.encAlgo = encAlgo;
+                header.encAlgo = r.readN(size);
             },
             3 => {
                 // compression algorithm uint32, we only use the first byte as this is 0 or 1
                 std.debug.assert(size == 4);
-                const compAlgo = ptr[offset];
-                header.compAlgo = compAlgo;
+                header.compAlgo = r.readU32(); 
             },
             4 => {
                 // salt, 32 bytes
                 std.debug.assert(size == 32);
-                const salt = ptr[offset .. offset + size];
-                header.salt = salt;
-            },
-            7 => {
-                // nonce, byte array
-                const nonce = ptr[offset .. offset + size];
-                header.nonce = nonce;
+                header.salt = r.readN(32);
             },
             11 => {
                 // kdf parameters, dictionary
-                const kdfParams = try parseKdfParams(ptr[offset..]);
-                header.kdfParams = kdfParams;
+                std.debug.print("hello", .{});
+                header.kdfParams = try parseKdfParams(r);
             },
             12 => {
                 // public custom data, dictionary
-                const customData = try parseCustomData(ptr[offset..]);
-                header.customData = customData;
+                // const customData = try parseCustomData(ptr[offset..]);
+                // header.customData = customData;
             },
             else => {
+                std.debug.print("id: {}", .{id});
                 return Error.CorruptedHeader;
             },
         }
-
-        offset += size;
     }
 }
 
 pub fn main() !void {
+    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
+    defer arena.deinit();
+    const allocator = arena.allocator();
+
     const in = std.mem.span(std.os.argv[1]);
+    const passwd = std.mem.span(std.os.argv[2]);
+
+    const digestLength = 256 / 8;
+    var hashedPasswd: [digestLength]u8 = undefined;
+    sha2.Sha256.hash(passwd, &hashedPasswd, .{});
+
     const file = try std.fs.cwd().openFile(in, .{ .mode = .read_write });
     const md = try file.metadata();
 
-    const ptr = try std.posix.mmap(null, @intCast(md.size()), std.posix.PROT.READ | std.posix.PROT.WRITE, .{ .TYPE = .SHARED }, file.handle, 0);
-    const sig: [*]u32 = @ptrCast(ptr[0..12]);
+    const ptr = try std.posix.mmap(
+        null, 
+        @intCast(md.size()),
+        std.posix.PROT.READ | std.posix.PROT.WRITE,
+        .{ .TYPE = .SHARED }, 
+        file.handle, 0
+    );
+
+    var r = Reader{
+        .ptr = ptr,
+        .idx = 0
+    };
 
-    if (sig[0] != 0x9aa2d903) {
+    if (r.readU32() != 0x9aa2d903) {
         return Error.CorruptedSignature;
     }
 
-    if (sig[1] != 0xb54bfb67) {
+    if (r.readU32() != 0xb54bfb67) {
         return Error.CorruptedSignature;
     }
 
-    const version = sig[2];
-
+    const version = r.readU32();
     // TODO: add proper version checking
+    
     std.debug.print("Version: {x}\n", .{version});
-
-    const header = try parseHeader(ptr[12..]);
+    // make a reader for this pointer slice reading
+    const header = try parseHeader(&r);
 
     switch (header.kdfParams.?) {
         .aesKdf => |*params| {
             std.debug.print("aes-kdf params: {}", .{params.*});
         },
         .argon2 => |*params| {
-            std.crypto.argon2.kdf();
-            std.debug.print("argon params: {}", .{params.*});
+            // 32 byte is the length of the salt
+            var derivedKey: [digestLength]u8 = undefined;
+            const mode: argon2.Mode = if (!params.*.isHybrid) .argon2d else .argon2id;
+            try argon2.kdf(
+                allocator,
+                &derivedKey,
+                &hashedPasswd,
+                params.*.salt.?,
+                .{
+                    .t = @intCast(params.*.it.?),
+                    // The api expects the memory to be in kibibytes
+                    .m = @intCast(params.*.mem.? / 1024),
+                    .p = @intCast(params.*.par.?)
+                },
+                mode
+            );
+
+            // The encryption key is somehow 32 bytes as well...
+            var encryptionKey: [digestLength]u8 = undefined;
+            // The salt is 32 byte long
+            const concated = header.salt.?[0..32].* ++ derivedKey;
+            sha2.Sha256.hash(&concated, &encryptionKey, .{});
+
+            const hmacConcated = concated ++ [_]u8{0x01};
+            var intermediateHash: [digestLength * 2]u8 = undefined;
+            sha2.Sha512.hash(&hmacConcated, &intermediateHash, .{});
+
+            const intConcated = [_]u8{0xFF} ** 8 ++ intermediateHash;
+            var hmacHashKey: [digestLength * 2]u8 = undefined;
+            sha2.Sha512.hash(&intConcated, &hmacHashKey, .{});
+
+            std.debug.print("encrytion key: {x}\n", .{encryptionKey});
+            std.debug.print("hmac hash key: {x}\n", .{hmacHashKey});
         }
     }
-
-    std.debug.print("header: {}\n", .{header});
 }
 
 test "simple test" {}
